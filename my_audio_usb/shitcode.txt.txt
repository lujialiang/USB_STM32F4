s16 fir(s16 NewSample) {

    static s16 x[Ntap]; //input samples
    int32_t y=0;            //output sample
    int n;

    //shift the old samples
    for(n=Ntap-1; n>0; n--)
       x[n] = x[n-1];

    //Calculate the new output
    x[0] = NewSample;
    for(n=0; n<Ntap; n++)
        y += FIRCoef[n] * x[n];
    //y= __SMUAD  (FIRCoef[n],x[n]);
    //__ASM volatile ("smlabb %0, %1, %2, %3" : "=r" (y) : "r" (FIRCoef[n]), "r" (x[n]), "r" (y) );
    return y / DCgain;
}

s16 fir2(s16 NewSample) {

    static s16 x[Ntap]; //input samples
    int32_t y=0;            //output sample
    int n;

    //shift the old samples
    for(n=Ntap-1; n>0; n--)
       x[n] = x[n-1];

    //Calculate the new output
    x[0] = NewSample;
    for(n=0; n<Ntap; n++)
        y += FIRCoef[n] * x[n];
    //y= __SMUAD  (FIRCoef[n],x[n]);
    //__ASM volatile ("smlabb %0, %1, %2, %3" : "=r" (y) : "r" (FIRCoef[n]), "r" (x[n]), "r" (y) );
    return y / DCgain;
}

#define NCoef 16
#define DCgain 8

static const int16_t ACoef[NCoef+1] = {
        1,
       31,
      238,
     1112,
     3615,
     8677,
    15908,
    22726,
    25567,
    22726,
    15908,
     8677,
     3615,
     1112,
      238,
       31,
        1
};

static const int16_t BCoef[NCoef+1] = {
     2048,
     -542,
     7658,
    -4884,
    13809,
    -12138,
    16902,
    -15456,
    14939,
    -12126,
     9161,
    -6109,
     3642,
    -1858,
      832,
     -266,
       80
};

int16_t iir(int16_t NewSample) {

    static int64_t y[NCoef+1]; //output samples
    //Warning!!!!!! This variable should be signed (input sample width + Coefs width + 16 )-bit width to avoid saturation.
//    static int32_t yy0,yy1;
    //static int16_t xx0,xx1;

    static int16_t x[NCoef+1]; //input samples
    int n;

    //shift the old samples
    for(n=NCoef; n>0; n--) {
       x[n] = x[n-1];
       y[n] = y[n-1];
    }

    //Calculate the new output
    x[0] = NewSample;
    y[0] = ACoef[0] * x[0];
    for(n=1; n<=NCoef; n++)
       y[0] += ACoef[n] * x[n] - BCoef[n] * y[n];
    //y= (int32_t) __SMUSD  (ACoef[n]<<16|BCoef[n],x[n]<<16|y[n]);
    /*{y[0]= (int32_t) __SMLSD  (ACoef[n]|(BCoef[n]<<16),x[n]|(y[n]<<16),y[0]);
    //y[0]= (int32_t) __SMLSD  (-BCoef[n]|((-BCoef[n+1])<<16),y[n]|(y[n+1]<<16),y[0]);
    };*/
    y[0] /= BCoef[0];
    return y[0] / DCgain;
    /*yy1=yy0;
    xx1=xx0;
    xx0= NewSample;*/
    /*yy0 = 28748*(xx0-xx1)+24730*yy1;
    return (yy0/32768);*/
}

int16_t iir2(int16_t NewSample) {

    static int64_t y[NCoef+1]; //output samples
    //Warning!!!!!! This variable should be signed (input sample width + Coefs width + 16 )-bit width to avoid saturation.
static int32_t yy0,yy1;
static int16_t xx0,xx1;
    static int16_t x[NCoef+1]; //input samples
    int n;

    //shift the old samples
    for(n=NCoef; n>0; n--) {
       x[n] = x[n-1];
       y[n] = y[n-1];
    }

    //Calculate the new output
    x[0] = NewSample;
    y[0] = ACoef[0] * x[0];
    for(n=1; n<=NCoef; n++)
       y[0] += ACoef[n] * x[n] - BCoef[n] * y[n];
    //y= (int32_t) __SMUSD  (ACoef[n]<<16|BCoef[n],x[n]<<16|y[n]);
    //y= (int32_t) __SMUAD  (-ACoef[n],x[n]);

    y[0] /= BCoef[0];
    return y[0] / DCgain;
    yy1=yy0;
    xx1=xx0;
    xx0= y[0] / DCgain;
    yy0 = 28748*(xx0-xx1)+24730*yy1;
    return (yy0/32768);

}


#define Ntap 200
#define DCgain 32768

s16 FIRCoef[Ntap] = {
       -35,
       -65,
        87,
         0,
       -89,
        69,
        38,
      -101,
        39,
        73,
       -97,
         0,
       100,
       -77,
       -42,
       112,
       -43,
       -82,
       109,
         0,
      -112,
        87,
        47,
      -127,
        49,
        92,
      -123,
         0,
       127,
       -98,
       -54,
       144,
       -56,
      -105,
       140,
         0,
      -145,
       113,
        62,
      -165,
        64,
       121,
      -162,
         0,
       168,
      -131,
       -72,
       193,
       -75,
      -142,
       190,
         0,
      -199,
       156,
        86,
      -231,
        90,
       171,
      -230,
         0,
       242,
      -190,
      -106,
       285,
      -112,
      -213,
       288,
         0,
      -307,
       243,
       136,
      -368,
       146,
       281,
      -382,
         0,
       416,
      -333,
      -189,
       518,
      -209,
      -408,
       564,
         0,
      -640,
       525,
       306,
      -867,
       362,
       736,
     -1069,
         0,
      1375,
     -1228,
      -798,
      2607,
     -1330,
     -3687,
      9636,
     20480,
      9636,
     -3687,
     -1330,
      2607,
      -798,
     -1228,
      1375,
         0,
     -1069,
       736,
       362,
      -867,
       306,
       525,
      -640,
         0,
       564,
      -408,
      -209,
       518,
      -189,
      -333,
       416,
         0,
      -382,
       281,
       146,
      -368,
       136,
       243,
      -307,
         0,
       288,
      -213,
      -112,
       285,
      -106,
      -190,
       242,
         0,
      -230,
       171,
        90,
      -231,
        86,
       156,
      -199,
         0,
       190,
      -142,
       -75,
       193,
       -72,
      -131,
       168,
         0,
      -162,
       121,
        64,
      -165,
        62,
       113,
      -145,
         0,
       140,
      -105,
       -56,
       144,
       -54,
       -98,
       127,
         0,
      -123,
        92,
        49,
      -127,
        47,
        87,
      -112,
         0,
       109,
       -82,
       -43,
       112,
       -42,
       -77,
       100,
         0,
       -97,
        73,
        39,
      -101,
        38,
        69,
       -89,
         0,
        87,
       -65,
       -35,
        90
 };

#ifdef DAC_CONFIG
DAC_Ch1_DMA_config(s16 * buf, uint16_t bufsize)
{

  DMA_InitTypeDef DMA_InitStructure;
  DAC_InitTypeDef	DAC_InitStructure;
  DAC_DeInit();

  /* DAC channel1 Configuration */
  DAC_InitStructure.DAC_Trigger = DAC_Trigger_T6_TRGO;
	DAC_InitStructure.DAC_LFSRUnmask_TriangleAmplitude=0;
  DAC_InitStructure.DAC_WaveGeneration = DAC_WaveGeneration_None;
  DAC_InitStructure.DAC_OutputBuffer = DAC_OutputBuffer_Enable;
  DAC_Init(DAC_Channel_1, &DAC_InitStructure);

  /* DMA1_Stream5 channel7 configuration **************************************/
  DMA_DeInit(DMA1_Stream5);
  DMA_InitStructure.DMA_Channel = DMA_Channel_7;
  DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t) buf;
  DMA_InitStructure.DMA_BufferSize = bufsize;
  #ifndef MPX_MODE
	DMA_InitStructure.DMA_PeripheralBaseAddr = DAC_DHR12LD_ADDRESS; //Both channels are simultaneously loaded
	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Word;
  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Word;
  #endif
  #ifdef MPX_MODE
  DMA_InitStructure.DMA_PeripheralBaseAddr = DAC_DHR12L1_ADDRESS; //Only channel1 is loaded
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;
  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;
  #endif
	DMA_InitStructure.DMA_DIR = DMA_DIR_MemoryToPeripheral;
  DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
  DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
  DMA_InitStructure.DMA_Priority = DMA_Priority_High;
  DMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Disable;
  DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_HalfFull;
  DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single;
  DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
  DMA_Init(DMA1_Stream5, &DMA_InitStructure);

  /* Enable DMA Stream Transfer Complete interrupt */
  DMA_ITConfig(DMA1_Stream5, DMA_IT_TC|DMA_IT_HT, ENABLE);

  /* Enable DMA1_Stream5 */
  DMA_Cmd(DMA1_Stream5, ENABLE);

  /* Enable DMA for DAC Channel1 */
  DAC_DMACmd(DAC_Channel_1, ENABLE);

  /* Enable DAC Channel1 */
  DAC_Cmd(DAC_Channel_1, ENABLE);

}

//DMA IRQ handler
//it is called every half if buffer is sent
void DMA1_Stream5_IRQHandler(void)
{
   if(DMA_GetITStatus(DMA1_Stream5,DMA_IT_HTIF5))	 /* DMA1 通道5 半传输中断 */
   {
DMA_ClearITPendingBit(DMA1_Stream5,DMA_IT_HTIF5);  /* DMA1 通道5 全局中断 */
		#ifndef MPX_mode
		 audio_buffer_fill |= LOW_EMPTY;
		#endif
		#ifdef MPX_mode
		 MPX_buffer_fill |= LOW_EMPTY;
		#endif
   }

   if(DMA_GetITStatus(DMA1_Stream5,DMA_IT_TCIF5))  /* DMA1 通道5 传输完成中断 */
   {
DMA_ClearITPendingBit(DMA1_Stream5,DMA_IT_TCIF5); /* DMA1 通道5 全局中断 */
  #ifndef MPX_mode
		 audio_buffer_fill |= HIGH_EMPTY;
	#endif
	#ifdef MPX_mode
		 MPX_buffer_fill |= HIGH_EMPTY;
	#endif
   }
}
#endif //DAC_CONFIG

//volatile uint32_t FTW_buf[2304] __attribute__ ((aligned(4)));
s16 fir(s16 NewSample);
int16_t iir(int16_t NewSample);
int16_t iir2(int16_t NewSample);

/*
const s16 LUT[1024]={
0, 201, 402, 603, 804, 1005, 1206, 1406, 1607, 1808, 2009,
2209, 2410, 2610, 2811, 3011, 3211, 3411, 3611, 3811, 4011,
4210, 4409, 4608, 4807, 5006, 5205, 5403, 5601, 5799, 5997,
6195, 6392, 6589, 6786, 6982, 7179, 7375, 7571, 7766, 7961,
8156, 8351, 8545, 8739, 8932, 9126, 9319, 9511, 9703, 9895,
10087, 10278, 10469, 10659, 10849, 11038, 11227, 11416, 11604,
11792, 11980, 12166, 12353, 12539, 12724, 12909, 13094, 13278,
13462, 13645, 13827, 14009, 14191, 14372, 14552, 14732, 14911,
16672, 16845, 17017, 17189, 17360, 17530, 17699, 17868, 18036,
18204, 18371, 18537, 18702, 18867, 19031, 19194, 19357, 19519,
19680, 19840, 20000, 20159, 20317, 20474, 20631, 20787, 20942,
21096, 21249, 21402, 21554, 21705, 21855, 22004, 22153, 22301,
22448, 22594, 22739, 22883, 23027, 23169, 23311, 23452, 23592,
23731, 23869, 24006, 24143, 24278, 24413, 24546, 24679, 24811,
26077, 26198, 26318, 26437, 26556, 26673, 26789, 26905, 27019,
27132, 27244, 27355, 27466, 27575, 27683, 27790, 27896, 28001,
28105, 28208, 28309, 28410, 28510, 28608, 28706, 28802, 28897,
28992, 29085, 29177, 29268, 29358, 29446, 29534, 29621, 29706,
29790, 29873, 29955, 30036, 30116, 30195, 30272, 30349, 30424,
30498, 30571, 30643, 30713, 30783, 30851, 30918, 30984, 31049,
31633, 31684, 31735, 31785, 31833, 31880, 31926, 31970, 32014,
32056, 32097, 32137, 32176, 32213, 32249, 32284, 32318, 32350,
32382, 32412, 32441, 32468, 32495, 32520, 32544, 32567, 32588,
32609, 32628, 32646, 32662, 32678, 32692, 32705, 32717, 32727,
32736, 32744, 32751, 32757, 32761, 32764, 32766, 32767, 32766,
32764, 32761, 32757, 32751, 32744, 32736, 32727, 32717, 32705,
32520, 32495, 32468, 32441, 32412, 32382, 32350, 32318, 32284,
32249, 32213, 32176, 32137, 32097, 32056, 32014, 31970, 31926,
31880, 31833, 31785, 31735, 31684, 31633, 31580, 31525, 31470,
31413, 31356, 31297, 31236, 31175, 31113, 31049, 30984, 30918,
30851, 30783, 30713, 30643, 30571, 30498, 30424, 30349, 30272,
29446, 29358, 29268, 29177, 29085, 28992, 28897, 28802, 28706,
28608, 28510, 28410, 28309, 28208, 28105, 28001, 27896, 27790,
27683, 27575, 27466, 27355, 27244, 27132, 27019, 26905, 26789,
26673, 26556, 26437, 26318, 26198, 26077, 25954, 25831, 25707,
25582, 25456, 25329, 25201, 25072, 24942, 24811, 24679, 24546,
24413, 24278, 24143, 24006, 23869, 23731, 23592, 23452, 23311,
23169, 23027, 22883, 22739, 22594, 22448, 22301, 22153, 22004,
21855, 21705, 21554, 21402, 21249, 21096, 20942, 20787, 20631,
20474, 20317, 20159, 20000, 19840, 19680, 19519, 19357, 19194,
19031, 18867, 18702, 18537, 18371, 18204, 18036, 17868, 17699,
17530, 17360, 17189, 17017, 16845, 16672, 16499, 16325, 16150,
15975, 15799, 15623, 15446, 15268, 15090, 14911, 14732, 14552,
14372, 14191, 14009, 13827, 13645, 13462, 13278, 13094, 12909,
11038, 10849, 10659, 10469, 10278, 10087, 9895, 9703, 9511, 9319,
9126, 8932, 8739, 8545, 8351, 8156, 7961, 7766, 7571, 7375, 7179,
6982, 6786, 6589, 6392, 6195, 5997, 5799, 5601, 5403, 5205, 5006,
4807, 4608, 4409, 4210, 4011, 3811, 3611, 3411, 3211, 3011, 2811,
2610, 2410, 2209, 2009, 1808, 1607, 1406, 1206, 1005, 804, 603, 402, 201, 0,
-202, -403, -604, -805, -1006, -1207, -1407, -1608, -1809, -2010, -2210,
-2411, -2611, -2812, -3012, -3212, -3412, -3612, -3812, -4012, -4211,
-4410, -4609, -4808, -5007, -5206, -5404, -5602, -5800, -5998, -6196,
-6393, -6590, -6787, -6983, -7180, -7376, -7572, -7767, -7962, -8157,
-8352, -8546, -8740, -8933, -9127, -9320, -9512, -9704, -9896, -10088,
-10279, -10470, -10660, -10850, -11039, -11228, -11417, -11605, -11793,
-11981, -12167, -12354, -12540, -12725, -12910, -13095, -13279, -13463,
-13646, -13828, -14010, -14192, -14373, -14553, -14733, -14912, -15091,
-15269, -15447, -15624, -15800, -15976, -16151, -16326, -16500, -16673,
-16846, -17018, -17190, -17361, -17531, -17700, -17869, -18037, -18205,
-18372, -18538, -18703, -18868, -19032, -19195, -19358, -19520, -19681,
-19841, -20001, -20160, -20318, -20475, -20632, -20788, -20943, -21097,
-21250, -21403, -21555, -21706, -21856, -22005, -22154, -22302, -22449,
-22595, -22740, -22884, -23028, -23170, -23312, -23453, -23593, -23732,
-23870, -24007, -24144, -24279, -24414, -24547, -24680, -24812, -24943,
-25073, -25202, -25330, -25457, -25583, -25708, -25832, -25955, -26078,
-26199, -26319, -26438, -26557, -26674, -26790, -26906, -27020, -27133,
-27245, -27356, -27467, -27576, -27684, -27791, -27897, -28002, -28106,
-28209, -28310, -28411, -28511, -28609, -28707, -28803, -28898, -28993,
-29086, -29178, -29269, -29359, -29447, -29535, -29622, -29707, -29791,
-29874, -29956, -30037, -30117, -30196, -30273, -30350, -30425, -30499,
-30572, -30644, -30714, -30784, -30852, -30919, -30985, -31050, -31114,
-31176, -31237, -31298, -31357, -31414, -31471, -31526, -31581, -31634,
-31685, -31736, -31786, -31834, -31881, -31927, -31971, -32015, -32057,
-32098, -32138, -32177, -32214, -32250, -32285, -32319, -32351, -32383,
-32413, -32442, -32469, -32496, -32521, -32545, -32568, -32589, -32610,
-32629, -32647, -32663, -32679, -32693, -32706, -32718, -32728, -32737,
-32745, -32752, -32758, -32762, -32765, -32767, -32767, -32767, -32765,
-32679, -32663, -32647, -32629, -32610, -32589, -32568, -32545, -32521,
-32496, -32469, -32442, -32413, -32383, -32351, -32319, -32285, -32250,
-32214, -32177, -32138, -32098, -32057, -32015, -31971, -31927, -31881,
-31834, -31786, -31736, -31685, -31634, -31581, -31526, -31471, -31414,
-31357, -31298, -31237, -31176, -31114, -31050, -30985, -30919, -30852,
-30784, -30714, -30644, -30572, -30499, -30425, -30350, -30273, -30196,
-30117, -30037, -29956, -29874, -29791, -29707, -29622, -29535, -29447,
-29359, -29269, -29178, -29086, -28993, -28898, -28803, -28707, -28609,
-28511, -28411, -28310, -28209, -28106, -28002, -27897, -27791, -27684,
-27576, -27467, -27356, -27245, -27133, -27020, -26906, -26790, -26674,
-26557, -26438, -26319, -26199, -26078, -25955, -25832, -25708, -25583,
-25457, -25330, -25202, -25073, -24943, -24812, -24680, -24547, -24414,
-24279, -24144, -24007, -23870, -23732, -23593, -23453, -23312, -23170,
-23028, -22884, -22740, -22595, -22449, -22302, -22154, -22005, -21856,
-21706, -21555, -21403, -21250, -21097, -20943, -20788, -20632, -20475,
-20318, -20160, -20001, -19841, -19681, -19520, -19358, -19195, -19032,
-17361, -17190, -17018, -16846, -16673, -16500, -16326, -16151, -15976,
-15800, -15624, -15447, -15269, -15091, -14912, -14733, -14553, -14373,
-14192, -14010, -13828, -13646, -13463, -13279, -13095, -12910, -12725,
-12540, -12354, -12167, -11981, -11793, -11605, -11417, -11228, -11039,
-10850, -10660, -10470, -10279, -10088, -9896, -9704, -9512, -9320, -9127,
-8933, -8740, -8546, -8352, -8157, -7962, -7767, -7572, -7376, -7180, -6983,
-6787, -6590, -6393, -6196, -5998, -5800, -5602, -5404, -5206, -5007,
-4808, -4609, -4410, -4211, -4012, -3812, -3612, -3412, -3212, -3012,
-2812, -2611, -2411, -2210, -2010, -1809, -1608, -1407, -1207, -1006,
-805, -604, -403, -202
};
*/

s16 fir(s16 NewSample);
s16 fir2(s16 NewSample);
int16_t iir(int16_t NewSample);
